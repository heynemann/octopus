<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Octopus by heynemann</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Octopus</h1>
        <p>octopus is a library to use threads to concurrently retrieve and report on the completion of http requests</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/heynemann/octopus" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/heynemann/octopus/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/heynemann/octopus/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>
<a name="octopus" class="anchor" href="#octopus"><span class="octicon octicon-link"></span></a>octopus</h1>

<p><a href="https://travis-ci.org/heynemann/octopus"><img src="https://travis-ci.org/heynemann/octopus.png?branch=master" alt="Build Status"></a>
<a href="https://crate.io/packages/octopus-http/"><img src="https://pypip.in/v/octopus-http/badge.png" alt="PyPi version"></a>
<a href="https://crate.io/packages/octopus-http/"><img src="https://pypip.in/d/octopus-http/badge.png" alt="PyPi downloads"></a>
<a href="https://coveralls.io/r/heynemann/octopus?branch=master"><img src="https://coveralls.io/repos/heynemann/octopus/badge.png?branch=master" alt="Coverage Status"></a></p>

<p><code>octopus</code> is a library to concurrently retrieve and report on the completion of http requests.</p>

<p>You can either use threads or the tornado IOLoop to asynchronously get them.</p>

<h1>
<a name="installing" class="anchor" href="#installing"><span class="octicon octicon-link"></span></a>Installing</h1>

<p>Installing <code>octopus</code> is really easy:</p>

<pre><code>$ pip install octopus-http
</code></pre>

<p>The reason for the name of the package is that a package called <code>octopus</code> was already registered at the Python Package Index.</p>

<h1>
<a name="using" class="anchor" href="#using"><span class="octicon octicon-link"></span></a>Using</h1>

<p>Using <code>octopus</code> with threads:</p>

<pre><code>from octopus import Octopus

# this Octopus instance we'll run 4 threads,
# automatically start listening to the queue and
# we'll in-memory cache responses for 10 seconds.
otto = Octopus(concurrency=4, auto_start=True, cache=True, expiration_in_seconds=10)

def handle_url_response(url, response):
    # do something with response

otto.enqueue('http://www.google.com', handle_url_response)
otto.enqueue('http://www.facebook.com', handle_url_response)
otto.enqueue('http://www.yahoo.com', handle_url_response)
otto.enqueue('http://www.google.com', handle_url_response)  # will come from the cache

otto.wait()  # waits until queue is empty or timeout is ellapsed
</code></pre>

<p>The analogous version with Tornado's IOLoop:</p>

<pre><code>from octopus import TornadoOctopus

# this Octopus instance we'll run 4 concurrent requests max,
# automatically start listening to the queue and
# we'll in-memory cache responses for 10 seconds.
otto = TornadoOctopus(concurrency=4, auto_start=True, cache=True, expiration_in_seconds=10)

def handle_url_response(url, response):
    # do something with response

otto.enqueue('http://www.google.com', handle_url_response)
otto.enqueue('http://www.facebook.com', handle_url_response)
otto.enqueue('http://www.yahoo.com', handle_url_response)
otto.enqueue('http://www.google.com', handle_url_response)  # will come from the cache

otto.wait()  # waits until queue is empty or timeout is ellapsed
</code></pre>

<h1>
<a name="api-reference" class="anchor" href="#api-reference"><span class="octicon octicon-link"></span></a>API Reference</h1>

<h2>
<a name="response-class" class="anchor" href="#response-class"><span class="octicon octicon-link"></span></a>Response Class</h2>

<p>The <code>Response</code> class is the result of all requests made with <code>Octopus</code> or <code>TornadoOctopus</code>.</p>

<p>It has the following information:</p>

<ul>
<li>
<code>url</code> - the url that started the request;</li>
<li>
<code>status_code</code> - the status code for the request;</li>
<li>
<code>cookies</code> - dictionary with request cookie values;</li>
<li>
<code>headers</code> - dictionary with response headers;</li>
<li>
<code>text</code> - the body of the response;</li>
<li>
<code>effective_url</code> - in the case of redirects, this url might be different than url;</li>
<li>
<code>error</code> - if an error has occurred this is where the error message will be;</li>
<li>
<code>request_time</code> - the time ellapsed between the start and the end of the request in seconds.</li>
</ul><h2>
<a name="octopus-class" class="anchor" href="#octopus-class"><span class="octicon octicon-link"></span></a>Octopus Class</h2>

<p>This is the main unit of work in <code>octopus</code> if you want to use threads. To enqueue new urls you need to have an <code>Octopus</code> instance:</p>

<pre><code>from octopus import Octopus

otto = Octopus()
</code></pre>

<p>The constructor for <code>Octopus</code> takes several configuration options:</p>

<ul>
<li>
<code>concurrency</code>: number of threads to use to retrieve URLs (defaults to 10 threads);</li>
<li>
<code>auto_start</code>: Indicates whether threads should be started automatically (defaults to False);</li>
<li>
<code>cache</code>: If set to <code>True</code>, responses will be cached for the number of seconds specified in <code>expiration_in_seconds</code> (defaults to False);</li>
<li>
<code>expiration_in_seconds</code>: The number of seconds to keep url responses in the local cache (defaults to 30 seconds);</li>
<li>
<code>request_timeout_in_seconds</code>: The number of seconds that each request can take (defaults to 5 seconds).</li>
</ul><h2>
<a name="octopusstart" class="anchor" href="#octopusstart"><span class="octicon octicon-link"></span></a>Octopus.start()</h2>

<p>If <code>auto_start</code> is set to <code>False</code>, this method must be called to start retrieving URLs. This is a <strong>non-blocking</strong> method.</p>

<h2>
<a name="octopusenqueueurl-handler-methodget-kwargs" class="anchor" href="#octopusenqueueurl-handler-methodget-kwargs"><span class="octicon octicon-link"></span></a>Octopus.enqueue(url, handler, method="GET", **kwargs)</h2>

<p>This is the main method in the <code>Octopus</code> class. This method is used to enqueue new URLs. The handler argument specifies the method to be called when the response is available.</p>

<p>The handler takes the form <code>handler(url, response)</code>. The response argument is a Octopus.Response instance.</p>

<p>You can specify a different method using the <code>method</code> argument (<code>POST</code>, <code>HEAD</code>, etc) and you can pass extra keyword arguments to the <code>requests.request</code> method using the keyword arguments for this method.</p>

<p>This is a <strong>non-blocking</strong> method.</p>

<h2>
<a name="octopusqueue_size" class="anchor" href="#octopusqueue_size"><span class="octicon octicon-link"></span></a>Octopus.queue_size</h2>

<p>This property returns the approximate number of URLs still in the queue (not retrieved yet).</p>

<h2>
<a name="octopusis_empty" class="anchor" href="#octopusis_empty"><span class="octicon octicon-link"></span></a>Octopus.is_empty</h2>

<p>This property returns if the URL queue is empty.</p>

<h2>
<a name="octopuswaittimeout10" class="anchor" href="#octopuswaittimeout10"><span class="octicon octicon-link"></span></a>Octopus.wait(timeout=10)</h2>

<p>If you want to wait for all the URLs in the queue to finish loading, just call this method.</p>

<p>If you specify a <code>timeout</code> of <code>0</code>, <code>octopus</code> will wait until the queue is empty, no matter how long it takes.</p>

<p>This is a <strong>blocking</strong> method.</p>

<h2>
<a name="tornadooctopus-class" class="anchor" href="#tornadooctopus-class"><span class="octicon octicon-link"></span></a>TornadoOctopus Class</h2>

<p>This is the main unit of work in <code>octopus</code> if you want to use Tornado's IOLoop. To enqueue new urls you need to have an <code>TornadoOctopus</code> instance:</p>

<pre><code>from octopus import TornadoOctopus

otto = TornadoOctopus()
</code></pre>

<p>A <strong>very important</strong> thing that differs from the threaded version of Octopus is that you <strong>MUST</strong> call wait to get the responses, since Tornado IOLoop needs to be run in order to get the requests.</p>

<p>The constructor for <code>TornadoOctopus</code> takes several configuration options:</p>

<ul>
<li>
<code>concurrency</code>: number of maximum async http requests to use to retrieve URLs (defaults to 10 requests);</li>
<li>
<code>auto_start</code>: Indicates whether the ioloop should be created automatically (defaults to False);</li>
<li>
<code>cache</code>: If set to <code>True</code>, responses will be cached for the number of seconds specified in <code>expiration_in_seconds</code> (defaults to False);</li>
<li>
<code>expiration_in_seconds</code>: The number of seconds to keep url responses in the local cache (defaults to 30 seconds);</li>
<li>
<code>request_timeout_in_seconds</code>: The number of seconds that each request can take (defaults to 10 seconds).</li>
<li>
<code>connect_timeout_in_seconds</code>: The number of seconds that each connection can take (defaults to 5 seconds).</li>
</ul><h2>
<a name="tornadooctopusstart" class="anchor" href="#tornadooctopusstart"><span class="octicon octicon-link"></span></a>TornadoOctopus.start()</h2>

<p>If <code>auto_start</code> is set to <code>False</code>, this method must be called to create the IOLoop instance. This is a <strong>non-blocking</strong> method.</p>

<h2>
<a name="tornadooctopusenqueueurl-handler-methodget-kwargs" class="anchor" href="#tornadooctopusenqueueurl-handler-methodget-kwargs"><span class="octicon octicon-link"></span></a>TornadoOctopus.enqueue(url, handler, method="GET", **kwargs)</h2>

<p>This is the main method in the <code>TornadoOctopus</code> class. This method is used to enqueue new URLs. The handler argument specifies the method to be called when the response is available.</p>

<p>The handler takes the form <code>handler(url, response)</code>. The response argument is a Octopus.Response instance.</p>

<p>You can specify a different method using the <code>method</code> argument (<code>POST</code>, <code>HEAD</code>, etc) and you can pass extra keyword arguments to the <code>AsyncHTTPClient.fetch</code> method using the keyword arguments for this method.</p>

<p>This is a <strong>non-blocking</strong> method.</p>

<h2>
<a name="tornadooctopusqueue_size" class="anchor" href="#tornadooctopusqueue_size"><span class="octicon octicon-link"></span></a>TornadoOctopus.queue_size</h2>

<p>This property returns the number of URLs still in the queue (not retrieved yet).</p>

<h2>
<a name="tornadooctopusis_empty" class="anchor" href="#tornadooctopusis_empty"><span class="octicon octicon-link"></span></a>TornadoOctopus.is_empty</h2>

<p>This property returns if the URL queue is empty.</p>

<h2>
<a name="tornadooctopuswaittimeout10" class="anchor" href="#tornadooctopuswaittimeout10"><span class="octicon octicon-link"></span></a>TornadoOctopus.wait(timeout=10)</h2>

<p>In order for the IOLoop to handle callbacks, you <strong>MUST</strong> call wait. This is the method that gets the IOLoop to run.</p>

<p>If you specify a <code>timeout</code> of <code>0</code>, <code>octopus</code> will wait until the queue is empty, no matter how long it takes.</p>

<p>This is a <strong>blocking</strong> method.</p>

<h1>
<a name="benchmark" class="anchor" href="#benchmark"><span class="octicon octicon-link"></span></a>Benchmark</h1>

<p>In order to decide whether <code>octopus</code> really was worth using, it features a benchmark test in it's codebase.</p>

<p>If you want to run it yourself (which is highly encouraged), just clone <code>octopus</code> repository and run this command:</p>

<pre><code>$ python benchmark/test_octopus.py 200 100
</code></pre>

<p>The first argument is the number of URLs to retrieve. The seconds argument means how many threads will be used by <code>octopus</code> to get the urls.</p>

<p>The test is pretty simple. Time how long it takes for requests to get the URLs sequentially and for <code>octopus</code> to get them concurrently.</p>

<p>The results for retrieving <code>2000</code> urls with <code>200</code> threads is as follows:</p>

<pre><code>=======
RESULTS
=======

[requests] Retrieving 2000 urls took 2692.66 seconds meaning 0.74 urls/second.

[octopus] Retrieving 2000 urls took 31.14 seconds meaning 64.22 urls/second.

[octopus] Retrieving 2000 urls with local in-memory caching took 6.61 seconds meaning 302.50 urls/second.

[octopus-tornado] Retrieving 2000 urls took 167.99 seconds meaning 11.91 urls/second.

[octopus-tornado-pycurl] Retrieving 2000 urls took 171.40 seconds meaning 11.67 urls/second.

Overall, threaded octopus was more than 86 times faster than sequential requests and tornado octopus was more than 15 times faster than sequential requests.
</code></pre>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/heynemann">heynemann</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-45782943-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>