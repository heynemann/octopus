<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Octopus by heynemann</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Octopus</h1>
          <h2>octopus is a library to use threads to concurrently retrieve and report on the completion of http requests</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/heynemann/octopus/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/heynemann/octopus/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/heynemann/octopus" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a name="octopus" class="anchor" href="#octopus"><span class="octicon octicon-link"></span></a>octopus</h1>

<p><a href="https://travis-ci.org/heynemann/octopus"><img src="https://travis-ci.org/heynemann/octopus.png?branch=master" alt="Build Status"></a>
<a href="https://crate.io/packages/octopus-http/"><img src="https://pypip.in/v/octopus-http/badge.png" alt="PyPi version"></a>
<a href="https://crate.io/packages/octopus-http/"><img src="https://pypip.in/d/octopus-http/badge.png" alt="PyPi downloads"></a>
<a href="https://coveralls.io/r/heynemann/octopus?branch=master"><img src="https://coveralls.io/repos/heynemann/octopus/badge.png?branch=master" alt="Coverage Status"></a></p>

<p><code>octopus</code> is a library to concurrently retrieve and report on the completion of http requests.</p>

<p>You can either use threads or the tornado IOLoop to asynchronously get them.</p>

<h1>
<a name="installing" class="anchor" href="#installing"><span class="octicon octicon-link"></span></a>Installing</h1>

<p>Installing <code>octopus</code> is really easy:</p>

<pre><code>$ pip install octopus-http
</code></pre>

<p>The reason for the name of the package is that a package called <code>octopus</code> was already registered at the Python Package Index.</p>

<h1>
<a name="using" class="anchor" href="#using"><span class="octicon octicon-link"></span></a>Using</h1>

<p>Using <code>octopus</code> with threads:</p>

<pre><code>from octopus import Octopus

# this Octopus instance we'll run 4 threads,
# automatically start listening to the queue and
# we'll in-memory cache responses for 10 seconds.
otto = Octopus(
    concurrency=4, auto_start=True, cache=True,
    expiration_in_seconds=10
)

def handle_url_response(url, response):
    # do something with response

otto.enqueue('http://www.google.com', handle_url_response)
otto.enqueue('http://www.facebook.com', handle_url_response)
otto.enqueue('http://www.yahoo.com', handle_url_response)

# this request will come from the cache
otto.enqueue('http://www.google.com', handle_url_response)  

otto.wait()  # waits until queue is empty or timeout is ellapsed
</code></pre>

<p>The analogous version with Tornado's IOLoop:</p>

<pre><code>from octopus import TornadoOctopus

# this Octopus instance we'll run 4 concurrent requests max,
# automatically start listening to the queue and
# we'll in-memory cache responses for 10 seconds.
otto = TornadoOctopus(
    concurrency=4, auto_start=True, cache=True,
    expiration_in_seconds=10
)

def handle_url_response(url, response):
    # do something with response

otto.enqueue('http://www.google.com', handle_url_response)
otto.enqueue('http://www.facebook.com', handle_url_response)
otto.enqueue('http://www.yahoo.com', handle_url_response)

# this request will come from the cache
otto.enqueue('http://www.google.com', handle_url_response)  

otto.wait()  # waits until queue is empty or timeout is ellapsed
</code></pre>

<h1>
<a name="api-reference" class="anchor" href="#api-reference"><span class="octicon octicon-link"></span></a>API Reference</h1>

<h2>
<a name="response-class" class="anchor" href="#response-class"><span class="octicon octicon-link"></span></a>Response Class</h2>

<p>The <code>Response</code> class is the result of all requests made with <code>Octopus</code> or <code>TornadoOctopus</code>.</p>

<p>It has the following information:</p>

<ul>
<li>
<code>url</code> - the url that started the request;</li>
<li>
<code>status_code</code> - the status code for the request;</li>
<li>
<code>cookies</code> - dictionary with request cookie values;</li>
<li>
<code>headers</code> - dictionary with response headers;</li>
<li>
<code>text</code> - the body of the response;</li>
<li>
<code>effective_url</code> - in the case of redirects, this url might be different than url;</li>
<li>
<code>error</code> - if an error has occurred this is where the error message will be;</li>
<li>
<code>request_time</code> - the time ellapsed between the start and the end of the request in seconds.</li>
</ul><h2>
<a name="octopus-class" class="anchor" href="#octopus-class"><span class="octicon octicon-link"></span></a>Octopus Class</h2>

<p>This is the main unit of work in <code>octopus</code> if you want to use threads. To enqueue new urls you need to have an <code>Octopus</code> instance:</p>

<pre><code>from octopus import Octopus

otto = Octopus()
</code></pre>

<p>The constructor for <code>Octopus</code> takes several configuration options:</p>

<ul>
<li>
<code>concurrency</code>: number of threads to use to retrieve URLs (defaults to 10 threads);</li>
<li>
<code>auto_start</code>: Indicates whether threads should be started automatically (defaults to False);</li>
<li>
<code>cache</code>: If set to <code>True</code>, responses will be cached for the number of seconds specified in <code>expiration_in_seconds</code> (defaults to False);</li>
<li>
<code>expiration_in_seconds</code>: The number of seconds to keep url responses in the local cache (defaults to 30 seconds);</li>
<li>
<code>request_timeout_in_seconds</code>: The number of seconds that each request can take (defaults to 5 seconds).</li>
<li>
<code>limiter</code>: The instance of a limiter class to use to acquire limits (more on limits below).</li>
</ul><h2>
<a name="octopusstart" class="anchor" href="#octopusstart"><span class="octicon octicon-link"></span></a>Octopus.start()</h2>

<p>If <code>auto_start</code> is set to <code>False</code>, this method must be called to start retrieving URLs. This is a <strong>non-blocking</strong> method.</p>

<h2>
<a name="octopusenqueue" class="anchor" href="#octopusenqueue"><span class="octicon octicon-link"></span></a>Octopus.enqueue</h2>

<p>Takes as arguments (url, handler, method="GET", **kwargs).</p>

<p>This is the main method in the <code>Octopus</code> class. This method is used to enqueue new URLs. The handler argument specifies the method to be called when the response is available.</p>

<p>The handler takes the form <code>handler(url, response)</code>. The response argument is a Octopus.Response instance.</p>

<p>You can specify a different method using the <code>method</code> argument (<code>POST</code>, <code>HEAD</code>, etc) and you can pass extra keyword arguments to the <code>requests.request</code> method using the keyword arguments for this method.</p>

<p>This is a <strong>non-blocking</strong> method.</p>

<h2>
<a name="octopusqueue_size" class="anchor" href="#octopusqueue_size"><span class="octicon octicon-link"></span></a>Octopus.queue_size</h2>

<p>This property returns the approximate number of URLs still in the queue (not retrieved yet).</p>

<h2>
<a name="octopusis_empty" class="anchor" href="#octopusis_empty"><span class="octicon octicon-link"></span></a>Octopus.is_empty</h2>

<p>This property returns if the URL queue is empty.</p>

<h2>
<a name="octopuswaittimeout10" class="anchor" href="#octopuswaittimeout10"><span class="octicon octicon-link"></span></a>Octopus.wait(timeout=10)</h2>

<p>If you want to wait for all the URLs in the queue to finish loading, just call this method.</p>

<p>If you specify a <code>timeout</code> of <code>0</code>, <code>octopus</code> will wait until the queue is empty, no matter how long it takes.</p>

<p>This is a <strong>blocking</strong> method.</p>

<h2>
<a name="tornadooctopus-class" class="anchor" href="#tornadooctopus-class"><span class="octicon octicon-link"></span></a>TornadoOctopus Class</h2>

<p>This is the main unit of work in <code>octopus</code> if you want to use Tornado's IOLoop. To enqueue new urls you need to have an <code>TornadoOctopus</code> instance:</p>

<pre><code>from octopus import TornadoOctopus

otto = TornadoOctopus()
</code></pre>

<p>A <strong>very important</strong> thing that differs from the threaded version of Octopus is that you <strong>MUST</strong> call wait to get the responses, since Tornado IOLoop needs to be run in order to get the requests.</p>

<p>The constructor for <code>TornadoOctopus</code> takes several configuration options:</p>

<ul>
<li>
<code>concurrency</code>: number of maximum async http requests to use to retrieve URLs (defaults to 10 requests);</li>
<li>
<code>auto_start</code>: Indicates whether the ioloop should be created automatically (defaults to False);</li>
<li>
<code>cache</code>: If set to <code>True</code>, responses will be cached for the number of seconds specified in <code>expiration_in_seconds</code> (defaults to False);</li>
<li>
<code>expiration_in_seconds</code>: The number of seconds to keep url responses in the local cache (defaults to 30 seconds);</li>
<li>
<code>request_timeout_in_seconds</code>: The number of seconds that each request can take (defaults to 10 seconds).</li>
<li>
<code>connect_timeout_in_seconds</code>: The number of seconds that each connection can take (defaults to 5 seconds).</li>
<li>
<code>limiter</code>: The instance of a limiter class to use to acquire limits (more on limits below).</li>
</ul><h2>
<a name="tornadooctopusstart" class="anchor" href="#tornadooctopusstart"><span class="octicon octicon-link"></span></a>TornadoOctopus.start()</h2>

<p>If <code>auto_start</code> is set to <code>False</code>, this method must be called to create the IOLoop instance. This is a <strong>non-blocking</strong> method.</p>

<h2>
<a name="tornadooctopusenqueue" class="anchor" href="#tornadooctopusenqueue"><span class="octicon octicon-link"></span></a>TornadoOctopus.enqueue</h2>

<p>Takes as arguments (url, handler, method="GET", **kwargs).</p>

<p>This is the main method in the <code>TornadoOctopus</code> class. This method is used to enqueue new URLs. The handler argument specifies the method to be called when the response is available.</p>

<p>The handler takes the form <code>handler(url, response)</code>. The response argument is a Octopus.Response instance.</p>

<p>You can specify a different method using the <code>method</code> argument (<code>POST</code>, <code>HEAD</code>, etc) and you can pass extra keyword arguments to the <code>AsyncHTTPClient.fetch</code> method using the keyword arguments for this method.</p>

<p>This is a <strong>non-blocking</strong> method.</p>

<h2>
<a name="tornadooctopusqueue_size" class="anchor" href="#tornadooctopusqueue_size"><span class="octicon octicon-link"></span></a>TornadoOctopus.queue_size</h2>

<p>This property returns the number of URLs still in the queue (not retrieved yet).</p>

<h2>
<a name="tornadooctopusis_empty" class="anchor" href="#tornadooctopusis_empty"><span class="octicon octicon-link"></span></a>TornadoOctopus.is_empty</h2>

<p>This property returns if the URL queue is empty.</p>

<h2>
<a name="tornadooctopuswaittimeout10" class="anchor" href="#tornadooctopuswaittimeout10"><span class="octicon octicon-link"></span></a>TornadoOctopus.wait(timeout=10)</h2>

<p>In order for the IOLoop to handle callbacks, you <strong>MUST</strong> call wait. This is the method that gets the IOLoop to run.</p>

<p>If you specify a <code>timeout</code> of <code>0</code>, <code>octopus</code> will wait until the queue is empty, no matter how long it takes.</p>

<p>This is a <strong>blocking</strong> method.</p>

<h1>
<a name="limiting-simultaneous-connections" class="anchor" href="#limiting-simultaneous-connections"><span class="octicon octicon-link"></span></a>Limiting Simultaneous Connections</h1>

<p>A very common problem that can happen when using octopus is overwhelming the server you are going to. In order to make sure this
does not happen, Octopus allows users to specify a limiter class.</p>

<p>Each limiter class has to provide two methods <code>acquire</code> and <code>release</code>, both taking an URL as argument.</p>

<p>Octopus comes bundled with an in-memory limiter and a redis limiter (courtesy of the <a href="https://github.com/bbangert/retools">retools project</a>). Using limiters is as simple as passing it to octopus constructor:</p>

<pre><code>from octopus import TornadoOctopus
from octopus.limiter.in_memory.per_domain import Limiter

# using in-memory limiter. Domains not specified here have no limit.
limiter = Limiter(
    {'http://globo.com': 10},  # only 10 concurrent requests to this domain
    {'http://g1.globo.com': 20},  # only 20 concurrent requests to this domain
)

otto = TornadoOctopus(
    concurrency=4, auto_start=True, cache=True,
    expiration_in_seconds=10,
    limiter=limiter
)
</code></pre>

<p>The available built-in limiters are:</p>

<ul>
<li><code>octopus.limiter.in_memory.per_domain.Limiter</code></li>
<li><code>octopus.limiter.redis.per_domain.Limiter</code></li>
</ul><p>Both take a list of dictionaries with the key being the beginning of the URL and value being the allowed concurrent connections.</p>

<p>The reason this is a list is that urls defined first take precedence. This allows users to single out a path in a domain that needs less connections than the rest of the domain, like this:</p>

<pre><code># using in-memory limiter. Domains not specified here have no limit.
limiter = Limiter(
    {'http://g1.globo.com/economia': 5},  # only 5 concurrent requests to urls that begin with this key
    {'http://g1.globo.com': 20},  # only 20 concurrent requests to the rest of the domain
)
</code></pre>

<p>The redis limiter takes two additional keyword arguments:
 <code>redis</code> (a <a href="https://github.com/andymccurdy/redis-py">redis.py</a> connection to redis)
 and <code>expiration_in_seconds</code> (the expiration for locks in the limiter).</p>

<p><strong>WARNING</strong>: The in-memory limiter <strong>IS NOT</strong> thread-safe, so if you are using Threaded Octopus, do not use this limiter.</p>

<p>If you'd like to do something when the limiter misses a lock (i.e.: no more connections allowed), just subscribe to it in the limiter using:</p>

<pre><code># using in-memory limiter. Domains not specified here have no limit.
limiter = Limiter(
    {'http://g1.globo.com/economia': 5},  # only 5 concurrent requests to urls that begin with this key
    {'http://g1.globo.com': 20},  # only 20 concurrent requests to the rest of the domain
)

def handle_lock_miss(url):
    # do something with the miss
    pass

limiter.subscribe_to_lock_miss(handle_lock_miss)
</code></pre>

<h1>
<a name="benchmark" class="anchor" href="#benchmark"><span class="octicon octicon-link"></span></a>Benchmark</h1>

<p>In order to decide whether <code>octopus</code> really was worth using, it features a benchmark test in it's codebase.</p>

<p>If you want to run it yourself (which is highly encouraged), just clone <code>octopus</code> repository and run this command:</p>

<pre><code>$ python benchmark/test_octopus.py 200 100
</code></pre>

<p>The first argument is the number of URLs to retrieve. The seconds argument means how many threads will be used by <code>octopus</code> to get the urls.</p>

<p>The test is pretty simple. Time how long it takes for requests to get the URLs sequentially and for <code>octopus</code> to get them concurrently.</p>

<p>The results for retrieving <code>2000</code> urls with <code>200</code> threads is as follows:</p>

<pre><code>=======
RESULTS
=======

[requests] Retrieving 2000 urls took 2692.66 seconds meaning 0.74 urls/second.

[octopus] Retrieving 2000 urls took 31.14 seconds meaning 64.22 urls/second.

[octopus] Retrieving 2000 urls with local in-memory caching took 6.61 seconds
meaning 302.50 urls/second.

[octopus-tornado] Retrieving 2000 urls took 167.99 seconds
meaning 11.91 urls/second.

[octopus-tornado-pycurl] Retrieving 2000 urls took 171.40 seconds
meaning 11.67 urls/second.

Overall, threaded octopus was more than 86 times faster than sequential requests
and tornado octopus was more than 15 times faster than sequential requests.
</code></pre>
        </section>

        <footer>
          Octopus is maintained by <a href="https://github.com/heynemann">heynemann</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

                  <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-45782943-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

      </div>
    </div>
  </body>
</html>